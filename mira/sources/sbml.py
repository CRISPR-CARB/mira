"""
Alternate XPath queries for COPASI data:

1. ``copasi:COPASI/rdf:RDF/rdf:Description/bqbiol:hasProperty``
2. ``copasi:COPASI/rdf:RDF/rdf:Description/CopasiMT:is``
"""

import bioregistry
import curies
from libsbml import SBMLDocument, SBMLReader
from lxml import etree
from tqdm import tqdm
from typing import Mapping, Optional
from pydantic import BaseModel
from mira.metamodel import Concept, ControlledConversion, NaturalConversion, NaturalDegradation, NaturalProduction
from mira.modeling import TemplateModel

__all__ = [
    "ParseResult",
    "template_model_from_sbml_file",
    "template_model_from_sbml_string",
    "template_model_from_sbml_document",
    "template_model_from_sbml_model",
]

PREFIX_MAP = {
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "dcterms": "http://purl.org/dc/terms/",
    "vCard": "http://www.w3.org/2001/vcard-rdf/3.0#",
    "vCard4": "http://www.w3.org/2006/vcard/ns#",
    "bqbiol": "http://biomodels.net/biology-qualifiers/",
    "bqmodel": "http://biomodels.net/model-qualifiers/",
    "CopasiMT": "http://www.copasi.org/RDF/MiriamTerms#",
    "copasi": "http://www.copasi.org/static/sbml",
}
RESOURCE_KEY = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}resource"
#: This XPath query gets annotations on species for their structured
#: identifiers, typically given as MIRIAM URIs or URNs
IDENTIFIERS_XPATH = f"rdf:RDF/rdf:Description/bqbiol:is/rdf:Bag/rdf:li"
#: This XPath query gets annotations on species about their properties,
#: which typically help ad-hoc create subclasses that are more specific
PROPERTIES_XPATH = f"rdf:RDF/rdf:Description/bqbiol:hasProperty/rdf:Bag/rdf:li"
#: This query helps get annotations on reactions, like "this reaction is a
#: _protein-containing complex disassembly_ (GO:0043624)"
IS_VERSION_XPATH = f"rdf:RDF/rdf:Description/bqbiol:hasProperty/rdf:Bag/rdf:li"

converter = curies.Converter.from_reverse_prefix_map(
    bioregistry.manager.get_reverse_prefix_map(include_prefixes=True)
)


class ParseResult(BaseModel):
    """A container of results from parsing an SBML document."""

    template_model: TemplateModel


def template_model_from_sbml_file(file, *, model_id: Optional[str] = None) -> ParseResult:
    """Extract a MIRA template model from a file containing SBML XML."""
    return template_model_from_sbml_string(file.read().decode("utf-8"), model_id=model_id)


def template_model_from_sbml_string(s: str, *, model_id: Optional[str] = None) -> ParseResult:
    """Extract a MIRA template model from a string representing SBML XML."""
    sbml_document = SBMLReader().readSBMLFromString(s)
    return template_model_from_sbml_document(sbml_document, model_id=model_id)


def template_model_from_sbml_document(sbml_document: SBMLDocument, *, model_id: Optional[str] = None) -> ParseResult:
    """Traverse an SBML document generated by libSBML and extract a MIRA Template model."""
    # see docs on models:
    # https://sbml.org/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_s_b_m_l_document.html
    sbml_model = sbml_document.getModel()
    return template_model_from_sbml_model(sbml_model, model_id=model_id)


def template_model_from_sbml_model(sbml_model, *, model_id: Optional[str] = None) -> ParseResult:
    """Traverse an SBML document generated by libSBML and extract a MIRA Template model."""
    concepts = _extract_concepts(sbml_model, model_id=model_id)

    # Iterate thorugh all reactions and piecewise convert to templates
    templates = []
    # see docs on reactions
    # https://sbml.org/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_reaction.html
    for reaction in sbml_model.getListOfReactions():
        reaction_id = reaction.getId()

        modifiers = [concepts[modifier.getSpecies()] for modifier in reaction.getListOfModifiers()]
        reactants = [concepts[reactant.getSpecies()] for reactant in reaction.getListOfReactants()]
        products = [concepts[product.getSpecies()] for product in reaction.getListOfProducts()]

        # check if reaction is reversible (i.e., reversible=False in the attributes),
        # then add a backwards conversion.
        if len(reactants) == 1 and len(products) == 1:
            if reactants[0].name and reactants[0] == products[0]:
                tqdm.write(f"[{model_id} reaction:{reaction_id}]")
                tqdm.write(f"Same reactant and product: {reactants[0]}")
                tqdm.write(f"Modifiers: {modifiers}")
                continue
            if len(modifiers) == 0:
                template = NaturalConversion(
                    subject=reactants[0],
                    outcome=products[0],
                )
                templates.append(template)
            elif len(modifiers) == 1:
                template = ControlledConversion(
                    subject=reactants[0],
                    outcome=products[0],
                    controller=modifiers[0],
                )
                templates.append(template)
            else:
                continue
                """
                could be the case that there's a linear combination of things that are independent
                - this could mean you could create multiple conversions
                
                but, they can be dependent too, then harder to break up
                """
                tqdm.write(f"[{model_id}] skipping reaction with multiple modifiers: {modifiers}")

        elif not reactants and not products:
            tqdm.write(f"[{model_id} reaction:{reaction_id}] missing reactants and products")
            continue
        elif products and not reactants:
            if len(products) == 1:
                template = NaturalProduction(
                    outcome=products[0],
                )
                templates.append(template)
            else:
                tqdm.write("can not yet handle multiple outcome natural production")
                continue
        elif reactants and not products:
            if len(reactants) == 1:
                template = NaturalDegradation(
                subject=reactants[0],
                )
                templates.append(template)
            else:
                tqdm.write("can not yet handle multiple outcome natural degradation")
                continue
        else:
            tqdm.write(
                f"[{model_id} reaction:{reaction_id}] skipping reaction with multiple inputs/outputs}")
            for i, inp in enumerate(reactants):
                tqdm.write(f"reactant {i}: {inp!r}")
            for i, inp in enumerate(products):
                tqdm.write(f"products {i}: {inp!r}")
            tqdm.write("")
            continue

        # Later - mathematical modeling can introduce more complicated dependencies
        # that don't show up at the wiring level

    template_model = TemplateModel(templates=templates)
    return ParseResult(template_model=template_model)


def _extract_concepts(sbml_model, *, model_id: Optional[str] = None) -> Mapping[str, Concept]:
    """Extract concepts from an SBML model."""
    concepts = {}
    # see https://sbml.org/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_species.html
    for species in sbml_model.getListOfSpecies():
        species_id = species.getId()
        species_name = species.getName()

        # The following traverses the annotations tag, which allows for
        # embedding arbitrary XML content. Typically, this is RDF.
        annotation_string = species.getAnnotationString()
        if not annotation_string:
            tqdm.write(f"[{model_id} species:{species_id}] had no annotations")
            concepts[species_id] = Concept(name=species_name, identifiers={}, context={})
            continue

        annotation_tree = etree.fromstring(annotation_string)
        rdf_properties = [
            converter.parse_uri(desc.attrib[RESOURCE_KEY])
            for desc in annotation_tree.findall(PROPERTIES_XPATH, namespaces=PREFIX_MAP)
        ]
        identifiers = dict(
            converter.parse_uri(element.attrib[RESOURCE_KEY])
            for element in annotation_tree.findall(IDENTIFIERS_XPATH, namespaces=PREFIX_MAP)
        )
        if model_id:
            identifiers["biomodel.species"] = f"{model_id}:{species_id}"
        concepts[species_id] = Concept(
            name=species_name or species_id,
            identifiers=identifiers,
            # TODO how to handle multiple properties? can we extend context to allow lists?
            context={"property": ":".join(rdf_properties[0])} if rdf_properties else {},
        )
    return concepts
